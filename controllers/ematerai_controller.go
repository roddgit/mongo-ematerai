package controllers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil" // io.ReadFile
	"log"
	"net/http"
	"time"

	"gin-mongo-api/configs"
	"gin-mongo-api/models"
	"gin-mongo-api/responses"

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"go.mongodb.org/mongo-driver/mongo"
)

var loginCollection *mongo.Collection = configs.GetCollection(configs.DB, "login")
var arr_config = configs.EnvMaterai()
var validateLogin = validator.New()

type Results struct {
	Name string
}

func LoginHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		// ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		var login models.Login
		// defer cancel()

		// validate the request body
		if err := c.BindJSON(&login); err != nil {
			c.JSON(http.StatusBadRequest, responses.LoginResponse{
				StatusCode: http.StatusBadRequest,
				Message:    "error",
				Result:     map[string]interface{}{"data": err.Error()}})
			return
		}

		// use the validator library to validate required fields
		if validationErr := validateLogin.Struct(&login); validationErr != nil {
			c.JSON(http.StatusBadRequest, responses.LoginResponse{
				StatusCode: http.StatusBadRequest,
				Message:    "error",
				Result:     map[string]interface{}{"data": validationErr.Error()}})
			return
		}

		// url_api := configs.EnvMaterai()
		reqData, _ := json.Marshal(login)

		strData := bytes.NewBuffer(reqData)

		url_api := arr_config["BASE_API"] + "api/users/login"

		client_http := &http.Client{
			Timeout: 10 * time.Second,
		}

		resp, err := client_http.Post(url_api, "application/json", strData)

		if err != nil {
			log.Fatalf("An Error Occured %v", err)
		}
		defer resp.Body.Close()
		//Read the response body
		respBody, err := ioutil.ReadAll(resp.Body)

		// Json read
		// var dataJson interface{}
		// json.NewDecoder(resp.Body).Decode(dataJson)

		if err != nil {
			log.Fatalln(err)
		}

		jsonString := string(respBody)
		log.Printf(jsonString)

		dataJson := map[string]interface{}{}
		if err := json.Unmarshal([]byte(respBody), &dataJson); err != nil {
			log.Fatal(err)
		}

		fmt.Println(dataJson["result"])
		md, _ := dataJson["result"].(map[string]interface{})
		fmt.Println(md["data"])

		// resultsc := dataJson["result"].([]Results)

		var structJson models.AutoGenerated
		if err := json.Unmarshal([]byte(respBody), &structJson); err != nil {
			fmt.Println("Can not unmarshal JSON")
		}
		fmt.Println(PrettyPrint(structJson))

		// newLogin := models.Login{
		// 	User:     login.User,
		// 	Password: login.Password,
		// }

		// result, err := loginCollection.InsertOne(ctx, newLogin)
		if err != nil {
			c.JSON(http.StatusInternalServerError, responses.LoginResponse{
				StatusCode: http.StatusInternalServerError,
				Message:    "error",
				Result:     map[string]interface{}{"data": err.Error()}})
			return
		}

		c.JSON(http.StatusOK, dataJson)

		// c.JSON(http.StatusCreated, responses.LoginResponse{
		// 	StatusCode: http.StatusCreated,
		// 	Message:    "success",
		// 	Result:     map[string]interface{}{"data": sb}})

	}
}

// PrettyPrint to print struct in a readable way
func PrettyPrint(i interface{}) string {
	s, _ := json.MarshalIndent(i, "", "\t")
	return string(s)
}

// func getJsonHTTP(url string, postData byte, target interface{}) error {
// 	var ht_client = &http.Client{Timeout: 10 * time.Second}
// 	r, err := ht_client.Post(url, "application/json", postData)
// 	if err != nil {
// 		return err
// 	}
// 	defer r.Body.Close()

// 	return json.NewDecoder(r.Body).Decode(target)
// }
