package controllers

import (
	"bytes"
	"context" // manage multiple requests
	"encoding/json"
	"fmt"
	"io/ioutil" // io.ReadFile
	"log"
	"net/http"
	"time"

	"gin-mongo-api/configs"
	"gin-mongo-api/models"
	"gin-mongo-api/responses"

	"github.com/Jeffail/gabs"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"go.mongodb.org/mongo-driver/mongo"
)

var loginCollection *mongo.Collection = configs.GetCollection(configs.DB, "login")
var arr_config = configs.EnvMaterai()
var validateLogin = validator.New()

type Results struct {
	Name string
}

func LoginHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		var login models.Login
		var logincek models.Login
		defer cancel()

		// validate the request body
		if err := c.BindJSON(&login); err != nil {
			c.JSON(http.StatusBadRequest, responses.LoginResponse{
				StatusCode: http.StatusBadRequest,
				Message:    "error",
				Result:     map[string]interface{}{"data": err.Error()}})
			return
		}

		// use the validator library to validate required fields
		if validationErr := validateLogin.Struct(&login); validationErr != nil {
			c.JSON(http.StatusBadRequest, responses.LoginResponse{
				StatusCode: http.StatusBadRequest,
				Message:    "error",
				Result:     map[string]interface{}{"data": validationErr.Error()}})
			return
		}

		// url_api := configs.EnvMaterai()
		reqData, _ := json.Marshal(login)

		strData := bytes.NewBuffer(reqData)

		url_api := arr_config["BASE_API"] + "api/users/login"

		client_http := &http.Client{
			Timeout: 10 * time.Second,
		}

		resp, err := client_http.Post(url_api, "application/json", strData)

		if err != nil {
			log.Fatalf("An Error Occured %v", err)
		}
		defer resp.Body.Close()
		//Read the response body
		respBody, err := ioutil.ReadAll(resp.Body)

		// Json read
		// var dataJson interface{}
		// json.NewDecoder(resp.Body).Decode(dataJson)

		if err != nil {
			log.Fatalln(err)
		}

		jsonString := string(respBody)
		log.Printf(jsonString)

		jsonParsed, err := gabs.ParseJSON(respBody)
		if err != nil {
			panic(err)
		}

		// Sample JSON
		// fmt.Println("Get value of Protected:\t", jsonParsed.Path("message").Data())
		// fmt.Println("Get value of Protected:\t", jsonParsed.Path("result.data.login.user.accounts").Index(0).S("tipeacct").String())

		dataJson := map[string]interface{}{}
		if err := json.Unmarshal([]byte(respBody), &dataJson); err != nil {
			log.Fatal(err)
		}

		statusCode := jsonParsed.Path("statusCode").Data().(string)

		if statusCode != "00" {
			c.JSON(http.StatusOK, dataJson)
			return
		}

		// filter := bson.D{{"user_id", jsonParsed.Path("result.data.login.user.id").Data().(string)}}
		// err := loginCollection.FindOne(ctx, filter).Decode(&logincek)
		// if err != nil { return err }

		fmt.Println(dataJson["result"])
		md, _ := dataJson["result"].(map[string]interface{})
		fmt.Println(md["data"])

		currentTime := time.Now().String()

		// Json Parsed method
		newLogin := models.SaveLogin{
			User_id:       jsonParsed.Path("result.data.login.user.id").Data().(string),
			Email:         jsonParsed.Path("result.data.login.user.email").Data().(string),
			Account_type:  jsonParsed.Path("result.data.login.user.accounts").Index(0).S("tipeacct").Data().(string),
			Token:         jsonParsed.Path("result.data.login.token").Data().(string),
			Date_modified: currentTime,
		}

		// Struct method
		// var structLogin models.AutoGeneratedLogin
		// if err := json.Unmarshal([]byte(respBody), &structLogin); err != nil {
		// 	fmt.Println("Can not unmarshal JSON")
		// }
		// fmt.Println(PrettyPrint(structLogin))
		// newLogin := models.SaveLogin{
		// 	User_id:       structLogin.Result.Data.Login.User.ID,
		// 	Email:         structLogin.Result.Data.Login.User.Email,
		// 	Account_type:  structLogin.Result.Data.Login.User.Accounts[0].Tipeacct,
		// 	Token:         structLogin.Result.Data.Login.Token,
		// 	Date_modified: currentTime,
		// }

		// var bdoc interface{}
		// err = bson.UnmarshalJSON([]byte(`{"id": 1,"name": "A green door","price": 12.50,"tags": ["home", "green"]}`), &bdoc)
		// if err != nil {
		// 	panic(err)
		// }

		result, err := loginCollection.InsertOne(ctx, newLogin)
		fmt.Println(PrettyPrint(result))

		if err != nil {
			c.JSON(http.StatusInternalServerError, responses.LoginResponse{
				StatusCode: http.StatusInternalServerError,
				Message:    "error",
				Result:     map[string]interface{}{"data": err.Error()}})
			return
		}

		c.JSON(http.StatusOK, dataJson)

		// c.JSON(http.StatusCreated, responses.LoginResponse{
		// 	StatusCode: http.StatusCreated,
		// 	Message:    "success",
		// 	Result:     map[string]interface{}{"data": sb}})

	}
}

// PrettyPrint to print struct in a readable way
func PrettyPrint(i interface{}) string {
	s, _ := json.MarshalIndent(i, "", "\t")
	return string(s)
}

// func getJsonHTTP(url string, postData byte, target interface{}) error {
// 	var ht_client = &http.Client{Timeout: 10 * time.Second}
// 	r, err := ht_client.Post(url, "application/json", postData)
// 	if err != nil {
// 		return err
// 	}
// 	defer r.Body.Close()

// 	return json.NewDecoder(r.Body).Decode(target)
// }
